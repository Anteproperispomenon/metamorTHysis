{-# LANGUAGE GeneralisedNewtypeDeriving #-}
{-# LANGUAGE DerivingStrategies #-}
{-# LANGUAGE TypeOperators #-}

module Metamorth.Interaction.Quasi.Parser.Types
  -- * Parser Information
  ( OrthographyDetails(..)
  -- * Specialised Parser Types
  , ParserQQ
  , embedQQ
  , ParserQQ1
  , liftQQ1
  , embedQQ1
  , embedQQ1_
  -- * Operations
  -- ** For ParserQQ
  , tellError
  , tellErrors
  , tellWarning
  , tellWarnings
  , tellMessage
  , tellMessages
  -- ** For ParserQQ1
  , setInputFile
  , setOutputFile
  , setUnifyBranches
  , setGroupGuards
  , setCheckStates
  , setInputName
  , setOutputName
  , setInSuffix
  , setOutSuffix
  , addCLIName
  , addCLINames
  , getOrthName
  ) where

import Control.Applicative
import Control.Monad

import Data.Maybe

import Data.String (IsString(..))

import Metamorth.Helpers.Error

import Data.Attoparsec.Text qualified as AT

import Control.Monad.Trans.Class
import Control.Monad.Trans.Writer.CPS
import Control.Monad.Trans.State.Strict

import Data.Text qualified as T

-- | Details generated by the QuasiQuoter.
data OrthographyDetails = OrthographyDetails
  { odName :: String -- or T.Text
  , odInputFile  :: Maybe FilePath
  , odOutputFile :: Maybe FilePath
  -- | Whether to unify branches for parser.
  , odUnifyBranches :: Maybe Bool
  -- | Whether to group guards for parser.
  , odGroupGuards   :: Maybe Bool
  -- | Whether to check states for parser.
  , odCheckStates   :: Maybe Bool
  -- | The name of the input parser function.
  , odInputName     :: Maybe String
  -- | The name of the output function.
  , odOutputName    :: Maybe String
  -- | The suffix used for internal parser functions.
  , odInSuffix      :: Maybe String
  -- | The suffix used for internal output functions.
  , odOutSuffix     :: Maybe String
  -- | The strings used to identify this parser
  --   for the CLI interface.
  , odCLINames      :: [String]
  } deriving (Show, Eq)

newtype ParserQQ' m a = ParserQQ { unpackParserQQ :: WriterT [ParserMessage] m a }
  deriving newtype (Functor, Applicative, Monad, MonadFail, MonadTrans, Alternative, MonadPlus)

-- | Parser used for parsing the quasi-quoter info.
type ParserQQ = ParserQQ' AT.Parser

instance (a ~ T.Text) => IsString (ParserQQ' AT.Parser a) where
  fromString = ParserQQ . lift . AT.string . T.pack

-- | Embed a `ParserQQ` value into a plain `AT.Parser`.
embedQQ :: ParserQQ a -> AT.Parser (a, [ParserMessage])
embedQQ (ParserQQ wrtr) = runWriterT wrtr

newtype ParserQQ1' m a = ParserQQ1 { unpackParserQQ1 :: StateT OrthographyDetails m a }
  deriving newtype (Functor, Applicative, Monad, MonadFail, MonadTrans, Alternative, MonadPlus)

type ParserQQ1 = ParserQQ1' ParserQQ

instance (a ~ T.Text) => IsString (ParserQQ1' ParserQQ a) where
  fromString = ParserQQ1 . lift . ParserQQ . lift . AT.string . T.pack

-- | Lifting from `AT.Parser` to `ParserQQ1`.
--   All other `lift` operations should be 
--   able to just use `lift`.
liftQQ1 :: AT.Parser a -> ParserQQ1 a
liftQQ1 = lift . lift

-- | Embed a `ParserQQ1` into a plain `ParserQQ`. This one
--   doesn't throw away the return value.
embedQQ1 :: String -> ParserQQ1 a -> ParserQQ (a, OrthographyDetails)
embedQQ1 nom (ParserQQ1 prs) = runStateT prs emptySt
  where
    emptySt = 
      OrthographyDetails 
        nom 
        Nothing
        Nothing
        Nothing
        Nothing
        Nothing
        Nothing
        Nothing
        Nothing
        Nothing
        []

-- | Embed a `ParserQQ1` into a plain `ParserQQ`. This one
--   ignores the return value and just returns the state.
embedQQ1_ :: String -> ParserQQ1 a -> ParserQQ OrthographyDetails
embedQQ1_ nom (ParserQQ1 prs) = execStateT prs emptySt
  where
    emptySt = 
      OrthographyDetails 
        nom 
        Nothing
        Nothing
        Nothing
        Nothing
        Nothing
        Nothing
        Nothing
        Nothing
        Nothing
        []

--------------------------------
-- Actual functions to use

----------------------------
-- For ParserQQ

tellError :: String -> ParserQQ ()
tellError str = ParserQQ $ tell [ParserError str]

tellErrors :: [String] -> ParserQQ ()
tellErrors strs = ParserQQ $ tell (map ParserError strs)

tellWarning :: String -> ParserQQ ()
tellWarning str = ParserQQ $ tell [ParserWarning str]

tellWarnings :: [String] -> ParserQQ ()
tellWarnings strs = ParserQQ $ tell (map ParserWarning strs)

tellMessage :: String -> ParserQQ ()
tellMessage str = ParserQQ $ tell [ParserMessage str]

tellMessages :: [String] -> ParserQQ ()
tellMessages strs = ParserQQ $ tell (map ParserMessage strs)

----------------------------
-- For ParserQQ1

setInputFile :: FilePath -> ParserQQ1 ()
setInputFile fp = ParserQQ1 $ do
  z <- gets odInputFile
  when (isJust z) $ do
    lift $ tellWarning "Setting input file more than once."
  modify' $ \x -> x {odInputFile = Just fp}

setOutputFile :: FilePath -> ParserQQ1 ()
setOutputFile fp = ParserQQ1 $ do
  z <- gets odOutputFile
  when (isJust z) $ do
    lift $ tellWarning "Setting output file more than once."
  modify' $ \x -> x {odOutputFile = Just fp}

setUnifyBranches :: Bool -> ParserQQ1 ()
setUnifyBranches bl = ParserQQ1 $ do
  z <- gets odUnifyBranches
  when (isJust z) $ do
    lift $ tellWarning "Setting \"Unify Branches\" flag more than once."
  modify' $ \x -> x {odUnifyBranches = Just bl}

setGroupGuards :: Bool -> ParserQQ1 ()
setGroupGuards bl = ParserQQ1 $ do
  z <- gets odGroupGuards
  when (isJust z) $ do
    lift $ tellWarning "Setting \"Group Guards\" flag more than once."
  modify' $ \x -> x {odGroupGuards = Just bl}

setCheckStates :: Bool -> ParserQQ1 ()
setCheckStates bl = ParserQQ1 $ do
  z <- gets odCheckStates
  when (isJust z) $ do
    lift $ tellWarning "Setting \"Check States\" flag more than once."
  modify' $ \x -> x {odCheckStates = Just bl}

setInputName :: String -> ParserQQ1 ()
setInputName str = ParserQQ1 $ do
  z <- gets odInputName
  when (isJust z) $ do
    lift $ tellWarning "Setting Input Function name more than once."
  modify' $ \x -> x {odInputName = Just str}

setOutputName :: String -> ParserQQ1 ()
setOutputName str = ParserQQ1 $ do
  z <- gets odOutputName
  when (isJust z) $ do
    lift $ tellWarning "Setting Output Function name more than once."
  modify' $ \x -> x {odOutputName = Just str}

setInSuffix :: String -> ParserQQ1 ()
setInSuffix str = ParserQQ1 $ do
  z <- gets odInSuffix
  when (isJust z) $ do
    lift $ tellWarning "Setting Input Suffix more than once."
  modify' $ \x -> x {odInSuffix = Just str}

setOutSuffix :: String -> ParserQQ1 ()
setOutSuffix str = ParserQQ1 $ do
  z <- gets odOutSuffix
  when (isJust z) $ do
    lift $ tellWarning "Setting Output name more than once."
  modify' $ \x -> x {odOutSuffix = Just str}

addCLIName :: String -> ParserQQ1 ()
addCLIName str = ParserQQ1 $ do
  strs <- gets odCLINames
  modify' $ \x -> x {odCLINames = str:strs}

addCLINames :: [String] -> ParserQQ1 ()
addCLINames strs = ParserQQ1 $ do
  rst <- gets odCLINames
  modify' $ \x -> x {odCLINames = strs++rst}

getOrthName :: ParserQQ1 String
getOrthName = ParserQQ1 $ gets odName

{-
  , odInputFile  :: Maybe FilePath
  , odOutputFile :: Maybe FilePath
  -- | Whether to unify branches for parser.
  , odUnifyBranches :: Maybe Bool
  -- | Whether to group guards for parser.
  , odGroupGuards   :: Maybe Bool
  -- | Whether to check states for parser.
  , odCheckStates   :: Maybe Bool
  -- | The name of the input parser function.
  , odInputName     :: Maybe String
  -- | The name of the output function.
  , odOutputName    :: Maybe String
  -- | The suffix used for internal parser functions.
  , odInSuffix      :: Maybe String
  -- | The suffix used for internal output functions.
  , odOutSuffix     :: Maybe String
  -- | The strings used to identify this parser
  --   for the CLI interface.

-}

